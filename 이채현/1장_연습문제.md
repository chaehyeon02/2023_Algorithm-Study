### 1. n개의 수로 구성된 리스트（또는 배열）에서 가장 큰 수를 찾는 알고리즘을 작성하시오.

```C++
int findMax(int len, int arr[]) {
	int max = arr[0];
	for(int i = 1; i < len; i++)
		if(arr[i] > max) 
			max = arr[i];
	return max;
}
```

### 2. n개의 수로 구성된 리스트에서 m 개의 가장 작은 수를 찾는 알고리즘을 작성하시오.
1번 코드에서 for문 안의 if문 부등호 방향만 바꿔주면 됨

### 3. n개의 원소로 구성된 집합에서 3개의 원소를 가진 부분집합을 모두 인쇄하는 알고리즘을 작성하시오.
```C++
void subset(int len, int arr[]) {
	for(int i = 0; i < len-2; i++) {
		for(int j = i+1; j < len-1; j++) {
			for(int k = i+2; k < len; k++)
				cout << "(" << arr[i] << ", " << arr[j] << ", " << arr[k] << ") ";
		}
	}
} 
```

### 8. 검색 작업을 하려 한다. 순차검색（알고리즘 1.1）이 적절함을 보여주는 상황을 설명하시오.
배열의 길이가 작은 경우. 순차검색의 시간 복잡도는 n이다. n이 작다면 순차검색을 사용해도 괜찮을 것이다...?

### 9. 정렬을 하는데 교환정렬（알고리즘 1.3）을 사용하지 말아야 할 실제 예를 드시오
입력 배열이 거꾸로 정렬된 경우. {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}

### 13. 알고리즘 刀는 10n2번의 단위연산을 수행하고, 알고리즘 B는 30011=.번의 단위연산을 수행한다. 어떤 n 값부터 알고리즘 끄의 성능이 좋아지는가?
```C++
int main() {
	int i = 0;
	while(10 * i * i <= 3001 * i) {
		i++;
		cout << 10 * i * i << ", " << 3001 * i << endl;
	}
	cout << "result: " << i;
}
```
이 코드를 사용해서 확인해보면 301부터 B의 성능이 좋음을 알 수 있다. 
